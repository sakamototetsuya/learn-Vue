# 记录在学习 Webpack 的过程及思路补充

# **一.环境所用包的安装**

*安装时一般有两种依赖方式：*

1. `npm i package -S`: **-S** 指定为写入 **dependencies** ，里面的插件需要发布到生产环境（即项目中没有该插件就无法运行，例如 JQuery）
2. `npm i package -D`: **-D** 指定为写入 **devDependencies** ，里面的插件只用于开发环境，不用于生产环境

***此时我们需要将 JQuery 安装到生产环境中（-S），而 Webpack 安装到开发环境中（-D）***

在**index.html**中，要想引入工程中需要的插件（如 JQuery），我们一般不会直接引用，因为打开页面时读取的静态资源太多会导致页面打开速度变慢（并且使用**webpack**就是为了解决这一问题），所以我们创建一个**main.js**的文件当做所有引用文件的入口，在里面使用语法`import **(变量名) from '**'(文件)`引入文件，即使用`import $ from 'jquery'`将JQuery引入工程

做完之后再命令行中使用`webpack 入口文件路径 出口文件路径`的语法创建在生产中使用的真正 JS 文件，本例为：`webpack ./src/main.js ../dist/bundle.js`,会自动创建一个名为 bundle.js 的文件，放置于 dist 文件夹

这时候需要在主页（index.html）中引入**bundled.js**文件以完成渲染

此外，因为 **webpack 4.0** 以后，需要指定模式，所以需要在以下文件中进行设置：

- 在 **package.json** 文件中的 **scripts** 对象中添加：

```json
 "dev": "webpack --mode development",  
 "build": "webpack --mode production"
```

其中，上面的指定为**开发模式**，下面的指定为**生产模式**

- 在 **webpack.config.js** 文件中添加：

```js
mode: 'development'
```

这里表示使用**开发模式**

------



# **二.基本配置---入口与出口的配置**

但是，因为每次更改样式后都需要重新使用`webpack ./src/main.js ../dist/bundle.js`渲染样式非常麻烦，所以我们希望能够更快捷的进行这项工作，为此，我们将更改**webpack**的配置

1. 首先在项目根目录下创建一个名为`webpack.config.js`的文件（固定名称）
2. 使用语法

```js
module.exports = {
    entry: path.join(__dirname, './src/main.js'),
    output: {
        path: path.join(__dirname, './dist'),
        filename: 'bundle.js'
    }
}
```

这个文件其实就是一个JS文件，通过 Node 中的模块操作，向外暴露了一个配置对象，我们可以手动指定 **入口和出口**

其中，**entry**指定入口，即需要使用 webpack 打包的文件。前面的是固定写法，后面的`./src/main.js`是入口文件的路径

**output**是一个对象，用于配置出口，首先配置出口路径，不同于**entry**的是，它需要使用**filename**指定作为出口的文件，本例中（或者说标准）使用**bundle.js**作为出口文件，即工程中实际引用的JS文件

完成了**入口和出口**的配置后，就可以直接使用`webpack`命令渲染文件了（以下是其执行步骤）：

1. 首先，**webpack** 发现命令没有指定入口和出口文件，所以它会去`webpack.config.js`中寻找
2. 找到该文件后，解析配置文件中的入口与出口
3. 使用导出的入口与出口进行打包构建
4. 每次使用 `webpack` 命令都会**重新**打包

------



# 三. webpack-dev-server 的基本使用

> 因为在页面渲染时，每次更改都要看到效果，但是使用**webpack**的话需要用命令行，非常不便。为了改善这一行为，我们可以安装**webpack-dev-server**，这个工具可以帮助我们自动完成打包编译

*起初当然是安装它* `npm i webpack-dev-server -D`

**注意：webpack-dev-server 依赖于 webpack ，并且强制要求将 webpack 安装在本地**

安装完毕后，在 **package.json** 中的 **scripts** 对象添加：

```json
"server":"webpack-dev-server"
```

> 这个 **server** 是作为命令来使用的，也可以使用其他未定义的指令。
>
> 这个语句表示：当我们使用 `npm run server` 命令时，运行 **webpack-dev-server**

这样就可以使用这个工具了，在命令行中输入

```cmd
npm run server
```

> 该命令开启了服务器模式，若要关闭，可在命令行窗口处按 **Ctrl+c**

每当我们保存项目更改时（一般是 **ctrl+s**）， **webpack-dev-server** 就会自动将代码打包，这样就不需要人为的输入命令进行打包工作了

但是，当我们打开页面时却发现没有效果，究其原因，是因为 **webpack-dev-server** 是将打包后的 **bundle.js** 保存在内存中，以节省打包时间。所以此时不能在页面中引用 `./dist/bundle.js` ，而是直接引用当前目录的。我们在 `index.html` 中引入文件 `<script src="bundle.js"></script>`

**注意：使用这个方式需要打开服务器，此时系统会分配一个端口号（默认是 8080），即要使用 webpack-dev-server 就必须使用服务器** 



------



## （1）配置 webpack-dev-server 的常用参数

> 为了更方便我们的操作，还可以为 **webpack-dev-server** 配置参数，这些参数可直接在 **package.json** 中的 **scripts** 对象添加
>
> *由于上一步我们已经添加了* `"server":"webpack-dev-server"` *，所以现在默认存在这行配置，接下来所举例的参数都是直接写在该行里面* 

### 1.1	--open

功能：***默认打开浏览器***

在使用`npm run server` 后，命令行会给我们生成一个本地服务器地址，可以藉由其打开浏览器页面。但是因为我们是懒惰的程序猿，添加了该参数之后，再运行刚才的命令可以直接打开浏览器

### 1.2	--port	[number]

功能：***修改默认端口号***

默认情况下，服务器打开的本地地址的端口号为**8080**，如果想要指定另一个端口号，就可配置该参数，**–port** 和数字之间以空格隔开，这里的空格很大是为了好看：），下同

### 1.3	--contentBase	[src]

功能：***在打开的浏览器中直接进入内容（即首页）***

只是使用**–port** 的话，浏览器只会显示出目录结构，若要直接进入首页，则需要这行参数。它指定打开浏览器后的显示内容，**[src]** 指定首页所在的位置（本例中的 **index.html** 正好存放在）

### 1.4	--hot

功能：***热重载***

启用热重载后，当你修改文件时，可以直接替换掉被修改的部分，**而不需要刷新页面** （即无刷新渲染页面）



## （2）配置参数的另一种方法（相对而言比较麻烦）

> 除了在 **package.json** 中配置之外，还可以在 **webpack-dev-server** 中构建一个 **decServer** 对象，在其中以键值对的形式配置参数

### 2.1	open : true

功能：***自动打开浏览器***

### 2.2	port : [number]

功能：***更改默认端口号***

### 2.3	content : [src]

功能：***设置托管的根目录***

### 2.4	hot : true

功能：***启用热重载***（第一步）

- 此外，还需要在 **webpack.config.js** 文件顶部添加一句（第二步）：

```js
const webpack = require('webpack);
```

- 再在文件中构建一个数组**plugins**（第三步）：

```js
plugins: [
    new webpack.HotModuleReplacementPlugin();
]
```

这个代码构建了一个热重载的模块对象

### 2.5	图示

![](F:\Microsoft VS Code\CODE\Vue\08  Webpack\src\images\QQ浏览器截图20181212165823.png)